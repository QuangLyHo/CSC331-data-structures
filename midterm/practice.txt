1.  Which of the following correctly initializes a doubly linked list in the default
    cnstructor?
    ans:    first = nullptr;
            last = nullptr;
            count = 0;

2.  int x, y

    x = 5
    y = 3

    stack.push(4)       // 4
    stack.push(x)       // 4 5
    stack.push(x + 1)   // 4 5 6

    y = stack.top()     // y = 6
    stack.pop()         // 4 5
    stack.push(x + y)   // 4 5 11
    x = stack.top()     // x = 11
    stack.pop()         // 4 5

    cout << "x = " << x << endl;    //output: x = 11
    cout << "y = " << y << endl;    //output: y = 6

3.  Every node (except for the last node) in a singly linked list conatains __?
    ans: b - the address of the next node

4.  Every node in a doubly linked list has two pointers: __ and __.
    ans: d - back; next

5.  Linked lists allow you to overcome the fixed array size limitations during 
    program execution. ans: True

6.  A pointer variable is a variable whose content is a memory address.
    ans: True

7.  What is the value of x after the following statements execute?
    int x = 23;
    int *p;
    p = &x;
    *p = 46;

    x = 46

8.  In c++, the dereferncing operator is __
    ans: *

9.  The __ deallocates the memory occupied by the nodes of a linked list when the linked
    list class.
    ans: a - destructor

10. Consider the following recursive definition, where n is a positive integer.
    f(1) = 3                n = 1
    f(3) = f(n - 1) + 1     n > 1

    f(3), 3 != 1, f(3 - 1) + 1  return 5
    f(2), 2 != 1, f(2 - 1) + 1  return 4
    f(1), 1 = 1, return 3

11. The __ element of the stack is the last element added to the stack
    ans: b - top

12. In a linked list, the link componenet of each node is a(n) __  
    ans: pointer

13. The link field of the last node of a linked list is __
    ans: nullptr

14. If you try to add a new item to a full stack, the resulting condition is called a(n)
    __.
    ans: overflow

15. In c++, operator is a reserved word.
    ans: True

[1,2,4,5] length = 4, location = 2
i = 4,                      4
for (int i = location; i < length - 1; i++)
    list[i] = list[i+1];
length--;


ATTEMPT 2:
1. 
struct studentType {
    char name[26];
    double gpa;
    int sID;
    char grade;
};

studentType student;
studentType *studentPtr;

4. What is the output of the following code?

queueType<int> queue;
int x, y;

x = 8;
y = 5;

queue.addQueue(12); // q = [12]
queue.addQueue(x); // q = [12, 8]
queue.addQueue(y); // q = [12, 8, 5]
x = queue.front(); // x = 12
queue.deleteQueue(); // q = [8, 5]
queue.addQueue(x + 2); // q = [8, 5, 14]
queue.addQueue(x); // q = [8, 5, 14, 12]
queue.addQueue(y - 3); // q = [8, 5, 14, 2]

y = queue.front(); y = 8
queue.deleteQueue(); // q = [5, 14, 2]

cout<< "x = " << x <<endl; // 12
cout<< "y = " << y <<endl; // 8

5. Consider the following definition of the recursive function print.

void print(int num)
{
  if (num > 0)
  {
     cout << num << " ";

     print(num - 1);
  }
}

What is the output of the following statement?

print(4);

4 3 2 1 

6. stackType<int> stack; LIFO
int x, y;

x = 4;
y = 2;
stack.push(6); [6]
stack.push(x); [6, 4]
stack.push(x + 1); [6, 4, 5]
y = stack.top(); y = 5
stack.pop(); [6,4]
stack.push(x + y); [6,4,9]
x = stack.top(); x = 9
stack.pop(); [6,4]

cout << "x = " << x << endl; // x = 9 

ATTEMPT 3:
1. queueType<int> queue; FIFO

int x, y;

x = 2;
y = 3;
queue.addQueue(x); q = [2]
queue.addQueue(y); q = [2, 3]
x = queue.front(); x = 2
queue.deleteQueue(); q = [3]
queue.addQueue(x + 2); q = [3, 4]
queue.addQueue(x); q = [3,4,2]
queue.addQueue(y - 3); q= [3,4,2,0]
y = queue.front(); y=3
queue.deleteQueue();q=[4,2,0]

cout << "x = " << x << endl; 2
cout << "y = " << y << endl;3



//insertAt (of the class arrayListType) to insert the item.

1.  Use an algorithm similar to binary search algoritm to find the palce where the item is to be inserted.
2.  If the item is already in the list:
        output an appropriate message
    else
        use the function insertAt to insert the item in the list.

template <class elemType>
void orderedArrayLsitType<elemType>::insertOrd(const elemType& item) {
    int first = 0;
    last = length - 1;
    int mid;

    bool found = false;

    if (length == 0) {
        list[0] = item;
        length++;
    }
    else if (length == maxSize) {
        cout << "Cannot insert into full list." << endl;
    } 
    else {
        while (first <= last && !found) {
            mid = (first + last) / 2;

            if (list[mid] == item) {
                found = true;
            }
            else if (item > list[mid]) {
                first = mid + 1;
            }
            else {
                last = mid - 1;
            } 
        }
    }

    if (found) {
        cout << "The item is already in the list.\nDuplicates are not allowed." << endl; 
    }
    else {
        if (list[mid] < item) {
            mid++;
        }
        insertAt(mid, item);
    }
}




template <class elemType>
void orderedArrayLsitType<elemType>::insertOrd(const elemType& item) {
    int left = 0;
    int right = length - 1;
    int mid;

    bool found = false;

    //If arrary is empty, insert into array
    if (length == 0) {
        list[0] = item;
        length++;
    }

    //Find the spot in the array for item
    else {
        while (left <= right && !found) {
            mid = ( left + right ) / 2;

            if (list[mid] == item) {
                found = true;
            }
            else if (item > list[mid]) 
                left = mid + 1;
            else
                right = mid - 1;
        }
    }

    //Determine if item is already in the list
    if (found) {
        cout << "Item is in the list." << endl;
    }
    else {

        left = 0 right = -1 mid = 0

        [2,3] item = 1
        if (list[mid] < item) 
            mid++;
        
        insertAt(mid, item);
    }

}